# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

type BulkDataObjectType {
  """The size of this file in integer bites"""
  compressedSize: Int!

  """
  The Content-Encoding encoding that will be used to transmit this file when you download it
  """
  contentEncoding: String!

  """The MIME type of this file"""
  contentType: String!

  """A human-readable description for this file"""
  description: String!

  """The URI that hosts this bulk file for fetching"""
  downloadUri: String!

  """The unique ID for this bulk item"""
  id: String!

  """A human-readable string for this file"""
  name: String!

  """The object type for this bulk item (always "bulk_data")"""
  object: String!

  """A computer-readable string for the kind of bulk item"""
  type: String!

  """The time when this file was last updated"""
  updatedAt: DateTime!

  """The Scryfall API URI for this file"""
  uri: String!
}

type Card {
  _count: CardCount!
  canBeFoil: Boolean!
  collections: [CardsInCollection!]
  collectorNumber: String
  currentPrice: ScryfallPrice!
  id: ID!
  isBorderless: Boolean!
  isPaper: Boolean!
  isShowcase: Boolean!
  scryfallCard: ScryfallCard!
  scryfallCardId: String!
}

type CardCount {
  collections: Int!
}

input CardListRelationFilter {
  every: CardWhereInput
  none: CardWhereInput
  some: CardWhereInput
}

input CardOrderByRelationAggregateInput {
  _count: SortOrder
}

input CardOrderByWithRelationInput {
  canBeFoil: SortOrder
  collections: CardsInCollectionOrderByRelationAggregateInput
  collectorNumber: SortOrder
  currentPrice: ScryfallPriceOrderByWithRelationInput
  id: SortOrder
  isBorderless: SortOrder
  isPaper: SortOrder
  isShowcase: SortOrder
  scryfallCard: ScryfallCardOrderByWithRelationInput
  scryfallCardId: SortOrder
}

input CardRelationFilter {
  is: CardWhereInput
  isNot: CardWhereInput
}

enum CardScalarFieldEnum {
  canBeFoil
  collectorNumber
  id
  isBorderless
  isPaper
  isShowcase
  scryfallCardId
}

input CardWhereInput {
  AND: [CardWhereInput!]
  NOT: [CardWhereInput!]
  OR: [CardWhereInput!]
  canBeFoil: BoolFilter
  collections: CardsInCollectionListRelationFilter
  collectorNumber: StringNullableFilter
  currentPrice: ScryfallPriceRelationFilter
  id: StringFilter
  isBorderless: BoolFilter
  isPaper: BoolFilter
  isShowcase: BoolFilter
  scryfallCard: ScryfallCardRelationFilter
  scryfallCardId: StringFilter
}

input CardWhereUniqueInput {
  id: String
  scryfallCardId: String
}

type CardsInCollection {
  card: Card!
  cardId: String!
  collection: Collection!
  collectionId: String!
  count: Int!
  isEtched: Boolean!
  isFoil: Boolean!
  price: CardsInCollectionCardPrice
}

input CardsInCollectionCardIdCollectionIdCompoundUniqueInput {
  cardId: String!
  collectionId: String!
}

type CardsInCollectionCardPrice {
  eur: Float!
  usd: Float!
}

input CardsInCollectionListRelationFilter {
  every: CardsInCollectionWhereInput
  none: CardsInCollectionWhereInput
  some: CardsInCollectionWhereInput
}

input CardsInCollectionOrderByRelationAggregateInput {
  _count: SortOrder
}

input CardsInCollectionOrderByWithRelationInput {
  card: CardOrderByWithRelationInput
  cardId: SortOrder
  collection: CollectionOrderByWithRelationInput
  collectionId: SortOrder
  count: SortOrder
  isEtched: SortOrder
  isFoil: SortOrder
}

enum CardsInCollectionScalarFieldEnum {
  cardId
  collectionId
  count
  isEtched
  isFoil
}

input CardsInCollectionUncheckedUpdateInput {
  cardId: StringFieldUpdateOperationsInput
  collectionId: StringFieldUpdateOperationsInput
  count: IntFieldUpdateOperationsInput
  isEtched: BoolFieldUpdateOperationsInput
  isFoil: BoolFieldUpdateOperationsInput
}

input CardsInCollectionWhereInput {
  AND: [CardsInCollectionWhereInput!]
  NOT: [CardsInCollectionWhereInput!]
  OR: [CardsInCollectionWhereInput!]
  card: CardRelationFilter
  cardId: StringFilter
  collection: CollectionRelationFilter
  collectionId: StringFilter
  count: IntFilter
  isEtched: BoolFilter
  isFoil: BoolFilter
}

input CardsInCollectionWhereUniqueInput {
  cardId_collectionId: CardsInCollectionCardIdCollectionIdCompoundUniqueInput
}

type Collection {
  _count: CollectionCount!
  cards(cursor: CardsInCollectionWhereUniqueInput, distinct: [CardsInCollectionScalarFieldEnum!], orderBy: [CardsInCollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CardsInCollectionWhereInput): [CardsInCollection!]!
  id: ID!
  name: String!
  user: User!
  userId: String!
}

type CollectionCount {
  cards: Int!
}

input CollectionListRelationFilter {
  every: CollectionWhereInput
  none: CollectionWhereInput
  some: CollectionWhereInput
}

input CollectionOrderByRelationAggregateInput {
  _count: SortOrder
}

input CollectionOrderByWithRelationInput {
  cards: CardsInCollectionOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input CollectionRelationFilter {
  is: CollectionWhereInput
  isNot: CollectionWhereInput
}

enum CollectionScalarFieldEnum {
  id
  name
  userId
}

input CollectionUserIdNameCompoundUniqueInput {
  name: String!
  userId: String!
}

input CollectionWhereInput {
  AND: [CollectionWhereInput!]
  NOT: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  cards: CardsInCollectionListRelationFilter
  id: StringFilter
  name: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input CollectionWhereUniqueInput {
  id: String
  userId_name: CollectionUserIdNameCompoundUniqueInput
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input FloatNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedFloatNullableFilter
  _min: NestedFloatNullableFilter
  _sum: NestedFloatNullableFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableWithAggregatesFilter
  notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableListFilter {
  equals: [Int!]
  has: Int
  hasEvery: [Int!]
  hasSome: [Int!]
  isEmpty: Boolean
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

input JsonFilter {
  equals: JSON
  not: JSON
}

input JsonNullableFilter {
  equals: JSON
  not: JSON
}

input JsonNullableListFilter {
  equals: [JSON!]
  has: JSON
  hasEvery: [JSON!]
  hasSome: [JSON!]
  isEmpty: Boolean
}

type Mutation {
  downloadBulkData(typeName: String!): Boolean!
  processAllParts: Boolean!
  processBulkData(fileName: String!): Boolean!
  processCardFaces: Boolean!
  processDaily: Boolean!
  processPriceData: Boolean!
  processSetData: Boolean!
  processUpdateCardList: Boolean!
  updateCardsInCollection(input: CardsInCollectionUncheckedUpdateInput!): CardsInCollection!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedFloatNullableFilter
  _min: NestedFloatNullableFilter
  _sum: NestedFloatNullableFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  allBulkData: [BulkDataObjectType!]!
  allCards(cursor: CardWhereUniqueInput, distinct: [CardScalarFieldEnum!], orderBy: [CardOrderByWithRelationInput!], skip: Int, take: Int, where: CardWhereInput): [Card!]!
  allCollections(cursor: CollectionWhereUniqueInput, distinct: [CollectionScalarFieldEnum!], orderBy: [CollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionWhereInput): [Collection!]!
  allScryfallCards(cursor: ScryfallCardWhereUniqueInput, distinct: [ScryfallCardScalarFieldEnum!], orderBy: [ScryfallCardOrderByWithRelationInput!], skip: Int, take: Int, where: ScryfallCardWhereInput): [ScryfallCard!]!
  allScryfallPrices(cursor: ScryfallPriceWhereUniqueInput, distinct: [ScryfallPriceScalarFieldEnum!], orderBy: [ScryfallPriceOrderByWithRelationInput!], skip: Int, take: Int, where: ScryfallPriceWhereInput): [ScryfallPrice!]!
  allScryfallSets(cursor: ScryfallSetWhereUniqueInput, distinct: [ScryfallSetScalarFieldEnum!], orderBy: [ScryfallSetOrderByWithRelationInput!], skip: Int, take: Int, where: ScryfallSetWhereInput): [ScryfallSet!]!
  getString: String!
}

enum QueryMode {
  default
  insensitive
}

type ScryfallCard {
  _count: ScryfallCardCount!
  allParts: [JSON!]
  arenaId: Int
  artist: String
  booster: Boolean!
  borderColor: String!
  card: [Card!]
  cardBackId: String
  cardFaces: [ScryfallCardFace!]!
  cardFacesRaw: [JSON!]
  cardmarketId: Int
  cmc: Float
  collectorNumber: String!
  colorIdentity: [String!]
  colorIndicator: [String!]
  colors: [String!]
  contentWarning: Boolean
  digital: Boolean!
  edhrecRank: Int
  finishes: [String!]
  flavorName: String
  frame: String!
  frameEffects: [String!]
  fullArt: Boolean!
  games: [String!]
  handModifier: String
  highresImage: Boolean!
  id: ID!
  illustrationId: String
  imageStatus: String!
  imageUris: JSON
  keywords: [String!]
  lang: String!
  layout: String!
  legalities: JSON!
  lifeModifier: String
  loyalty: String
  manaCost: String
  mtgoFoilId: Int
  mtgoId: Int
  multiverseIds: [Int!]
  name: String!
  oracleId: String
  oracleText: String
  oversized: Boolean!
  power: String
  prices: JSON!
  printedName: String
  printedText: String
  printedTypeLine: String
  printsSearchUri: String!
  producedMana: [String!]
  promo: Boolean!
  promoTypes: [String!]
  purchaseUris: JSON
  rarity: String!
  referencedBy: [ScryfallRelatedCard!]!
  relatedTo: [ScryfallRelatedCard!]!
  relatedUris: JSON!
  releasedAt: DateTime!
  reprint: Boolean!
  reserved: Boolean!
  rulingUri: String
  scryfallMostRecentPrice: ScryfallPrice
  scryfallPrice(cursor: ScryfallPriceWhereUniqueInput, distinct: [ScryfallPriceScalarFieldEnum!], orderBy: [ScryfallPriceOrderByWithRelationInput!], skip: Int, take: Int, where: ScryfallPriceWhereInput): [ScryfallPrice!]!
  scryfallPricesGroupBy(_avg: ScryfallPriceAvgAggregateInput, _count: ScryfallPriceCountAggregateInput, _max: ScryfallPriceMaxAggregateInput, _min: ScryfallPriceMinAggregateInput, _sum: ScryfallPriceSumAggregateInput, having: ScryfallPriceScalarWhereWithAggregatesInput, orderBy: [ScryfallPriceOrderByWithAggregationInput!], skip: Int, take: Int, where: ScryfallPriceWhereInput): [ScryfallPriceGroupBy!]!
  scryfallSetUri: String!
  scryfallUri: String!
  securityStamp: String
  set: ScryfallSet!
  setCode: String!
  setId: String!
  setName: String!
  setSearchUri: String!
  setType: String!
  setUri: String!
  storySpotlight: Boolean!
  tcgplayerEtchedId: Int
  tcgplayerId: Int
  textless: Boolean!
  toughness: String
  typeLine: String
  uri: String!
  varationOf: String
  variation: Boolean!
  watermark: String
}

type ScryfallCardCount {
  card: Int!
  cardFaces: Int!
  referencedBy: Int!
  relatedTo: Int!
  scryfallPrice: Int!
}

type ScryfallCardFace {
  artist: String
  card: ScryfallCard!
  cardId: String!
  cmc: Float
  colorIndicator: [String!]
  colors: [String!]
  flavorText: String
  id: ID!
  illustrationId: String
  imageUris: JSON
  layout: String
  loyalty: String
  manaCost: String
  name: String!
  oracleId: String
  oracleText: String
  power: String
  printedName: String
  printedText: String
  printedTypeLine: String
  toughness: String
  typeLine: String
  watermark: String
}

input ScryfallCardFaceListRelationFilter {
  every: ScryfallCardFaceWhereInput
  none: ScryfallCardFaceWhereInput
  some: ScryfallCardFaceWhereInput
}

input ScryfallCardFaceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ScryfallCardFaceWhereInput {
  AND: [ScryfallCardFaceWhereInput!]
  NOT: [ScryfallCardFaceWhereInput!]
  OR: [ScryfallCardFaceWhereInput!]
  artist: StringNullableFilter
  card: ScryfallCardRelationFilter
  cardId: StringFilter
  cmc: FloatNullableFilter
  colorIndicator: StringNullableListFilter
  colors: StringNullableListFilter
  flavorText: StringNullableFilter
  id: StringFilter
  illustrationId: StringNullableFilter
  imageUris: JsonNullableFilter
  layout: StringNullableFilter
  loyalty: StringNullableFilter
  manaCost: StringNullableFilter
  name: StringFilter
  oracleId: StringNullableFilter
  oracleText: StringNullableFilter
  power: StringNullableFilter
  printedName: StringNullableFilter
  printedText: StringNullableFilter
  printedTypeLine: StringNullableFilter
  toughness: StringNullableFilter
  typeLine: StringNullableFilter
  watermark: StringNullableFilter
}

input ScryfallCardListRelationFilter {
  every: ScryfallCardWhereInput
  none: ScryfallCardWhereInput
  some: ScryfallCardWhereInput
}

input ScryfallCardOrderByRelationAggregateInput {
  _count: SortOrder
}

input ScryfallCardOrderByWithRelationInput {
  allParts: SortOrder
  arenaId: SortOrder
  artist: SortOrder
  booster: SortOrder
  borderColor: SortOrder
  card: CardOrderByRelationAggregateInput
  cardBackId: SortOrder
  cardFaces: ScryfallCardFaceOrderByRelationAggregateInput
  cardFacesRaw: SortOrder
  cardmarketId: SortOrder
  cmc: SortOrder
  collectorNumber: SortOrder
  colorIdentity: SortOrder
  colorIndicator: SortOrder
  colors: SortOrder
  contentWarning: SortOrder
  digital: SortOrder
  edhrecRank: SortOrder
  finishes: SortOrder
  flavorName: SortOrder
  frame: SortOrder
  frameEffects: SortOrder
  fullArt: SortOrder
  games: SortOrder
  handModifier: SortOrder
  highresImage: SortOrder
  id: SortOrder
  illustrationId: SortOrder
  imageStatus: SortOrder
  imageUris: SortOrder
  keywords: SortOrder
  lang: SortOrder
  layout: SortOrder
  legalities: SortOrder
  lifeModifier: SortOrder
  loyalty: SortOrder
  manaCost: SortOrder
  mtgoFoilId: SortOrder
  mtgoId: SortOrder
  multiverseIds: SortOrder
  name: SortOrder
  oracleId: SortOrder
  oracleText: SortOrder
  oversized: SortOrder
  power: SortOrder
  prices: SortOrder
  printedName: SortOrder
  printedText: SortOrder
  printedTypeLine: SortOrder
  printsSearchUri: SortOrder
  producedMana: SortOrder
  promo: SortOrder
  promoTypes: SortOrder
  purchaseUris: SortOrder
  rarity: SortOrder
  referencedBy: ScryfallRelatedCardOrderByRelationAggregateInput
  relatedTo: ScryfallRelatedCardOrderByRelationAggregateInput
  relatedUris: SortOrder
  releasedAt: SortOrder
  reprint: SortOrder
  reserved: SortOrder
  rulingUri: SortOrder
  scryfallPrice: ScryfallPriceOrderByRelationAggregateInput
  scryfallSetUri: SortOrder
  scryfallUri: SortOrder
  securityStamp: SortOrder
  set: ScryfallSetOrderByWithRelationInput
  setCode: SortOrder
  setId: SortOrder
  setName: SortOrder
  setSearchUri: SortOrder
  setType: SortOrder
  setUri: SortOrder
  storySpotlight: SortOrder
  tcgplayerEtchedId: SortOrder
  tcgplayerId: SortOrder
  textless: SortOrder
  toughness: SortOrder
  typeLine: SortOrder
  uri: SortOrder
  varationOf: SortOrder
  variation: SortOrder
  watermark: SortOrder
}

input ScryfallCardRelationFilter {
  is: ScryfallCardWhereInput
  isNot: ScryfallCardWhereInput
}

enum ScryfallCardScalarFieldEnum {
  allParts
  arenaId
  artist
  booster
  borderColor
  cardBackId
  cardFacesRaw
  cardmarketId
  cmc
  collectorNumber
  colorIdentity
  colorIndicator
  colors
  contentWarning
  digital
  edhrecRank
  finishes
  flavorName
  frame
  frameEffects
  fullArt
  games
  handModifier
  highresImage
  id
  illustrationId
  imageStatus
  imageUris
  keywords
  lang
  layout
  legalities
  lifeModifier
  loyalty
  manaCost
  mtgoFoilId
  mtgoId
  multiverseIds
  name
  oracleId
  oracleText
  oversized
  power
  prices
  printedName
  printedText
  printedTypeLine
  printsSearchUri
  producedMana
  promo
  promoTypes
  purchaseUris
  rarity
  relatedUris
  releasedAt
  reprint
  reserved
  rulingUri
  scryfallSetUri
  scryfallUri
  securityStamp
  setCode
  setId
  setName
  setSearchUri
  setType
  setUri
  storySpotlight
  tcgplayerEtchedId
  tcgplayerId
  textless
  toughness
  typeLine
  uri
  varationOf
  variation
  watermark
}

input ScryfallCardWhereInput {
  AND: [ScryfallCardWhereInput!]
  NOT: [ScryfallCardWhereInput!]
  OR: [ScryfallCardWhereInput!]
  allParts: JsonNullableListFilter
  arenaId: IntNullableFilter
  artist: StringNullableFilter
  booster: BoolFilter
  borderColor: StringFilter
  card: CardListRelationFilter
  cardBackId: StringNullableFilter
  cardFaces: ScryfallCardFaceListRelationFilter
  cardFacesRaw: JsonNullableListFilter
  cardmarketId: IntNullableFilter
  cmc: FloatNullableFilter
  collectorNumber: StringFilter
  colorIdentity: StringNullableListFilter
  colorIndicator: StringNullableListFilter
  colors: StringNullableListFilter
  contentWarning: BoolNullableFilter
  digital: BoolFilter
  edhrecRank: IntNullableFilter
  finishes: StringNullableListFilter
  flavorName: StringNullableFilter
  frame: StringFilter
  frameEffects: StringNullableListFilter
  fullArt: BoolFilter
  games: StringNullableListFilter
  handModifier: StringNullableFilter
  highresImage: BoolFilter
  id: StringFilter
  illustrationId: StringNullableFilter
  imageStatus: StringFilter
  imageUris: JsonNullableFilter
  keywords: StringNullableListFilter
  lang: StringFilter
  layout: StringFilter
  legalities: JsonFilter
  lifeModifier: StringNullableFilter
  loyalty: StringNullableFilter
  manaCost: StringNullableFilter
  mtgoFoilId: IntNullableFilter
  mtgoId: IntNullableFilter
  multiverseIds: IntNullableListFilter
  name: StringFilter
  oracleId: StringNullableFilter
  oracleText: StringNullableFilter
  oversized: BoolFilter
  power: StringNullableFilter
  prices: JsonFilter
  printedName: StringNullableFilter
  printedText: StringNullableFilter
  printedTypeLine: StringNullableFilter
  printsSearchUri: StringFilter
  producedMana: StringNullableListFilter
  promo: BoolFilter
  promoTypes: StringNullableListFilter
  purchaseUris: JsonNullableFilter
  rarity: StringFilter
  referencedBy: ScryfallRelatedCardListRelationFilter
  relatedTo: ScryfallRelatedCardListRelationFilter
  relatedUris: JsonFilter
  releasedAt: DateTimeFilter
  reprint: BoolFilter
  reserved: BoolFilter
  rulingUri: StringNullableFilter
  scryfallPrice: ScryfallPriceListRelationFilter
  scryfallSetUri: StringFilter
  scryfallUri: StringFilter
  securityStamp: StringNullableFilter
  set: ScryfallSetRelationFilter
  setCode: StringFilter
  setId: StringFilter
  setName: StringFilter
  setSearchUri: StringFilter
  setType: StringFilter
  setUri: StringFilter
  storySpotlight: BoolFilter
  tcgplayerEtchedId: IntNullableFilter
  tcgplayerId: IntNullableFilter
  textless: BoolFilter
  toughness: StringNullableFilter
  typeLine: StringNullableFilter
  uri: StringFilter
  varationOf: StringNullableFilter
  variation: BoolFilter
  watermark: StringNullableFilter
}

input ScryfallCardWhereUniqueInput {
  id: String
}

type ScryfallPrice {
  card: ScryfallCard!
  cardId: String!
  currentPriceOfCard: Card
  currentPriceOfCardId: String
  date: DateTime!
  eur: Float
  eurFoil: Float
  id: ID!
  tix: Float
  usd: Float
  usdEtched: Float
  usdFoil: Float
}

type ScryfallPriceAvgAggregate {
  eur: Float
  eurFoil: Float
  tix: Float
  usd: Float
  usdEtched: Float
  usdFoil: Float
}

input ScryfallPriceAvgAggregateInput {
  eur: Boolean
  eurFoil: Boolean
  tix: Boolean
  usd: Boolean
  usdEtched: Boolean
  usdFoil: Boolean
}

input ScryfallPriceAvgOrderByAggregateInput {
  eur: SortOrder
  eurFoil: SortOrder
  tix: SortOrder
  usd: SortOrder
  usdEtched: SortOrder
  usdFoil: SortOrder
}

type ScryfallPriceCountAggregate {
  _all: Int!
  cardId: Int!
  currentPriceOfCardId: Int!
  date: Int!
  eur: Int!
  eurFoil: Int!
  id: Int!
  tix: Int!
  usd: Int!
  usdEtched: Int!
  usdFoil: Int!
}

input ScryfallPriceCountAggregateInput {
  _all: Boolean
  cardId: Boolean
  currentPriceOfCardId: Boolean
  date: Boolean
  eur: Boolean
  eurFoil: Boolean
  id: Boolean
  tix: Boolean
  usd: Boolean
  usdEtched: Boolean
  usdFoil: Boolean
}

input ScryfallPriceCountOrderByAggregateInput {
  cardId: SortOrder
  currentPriceOfCardId: SortOrder
  date: SortOrder
  eur: SortOrder
  eurFoil: SortOrder
  id: SortOrder
  tix: SortOrder
  usd: SortOrder
  usdEtched: SortOrder
  usdFoil: SortOrder
}

type ScryfallPriceGroupBy {
  _avg: ScryfallPriceAvgAggregate
  _count: ScryfallPriceCountAggregate
  _max: ScryfallPriceMaxAggregate
  _min: ScryfallPriceMinAggregate
  _sum: ScryfallPriceSumAggregate
  cardId: String!
  currentPriceOfCardId: String
  date: DateTime!
  eur: Float
  eurFoil: Float
  id: String!
  tix: Float
  usd: Float
  usdEtched: Float
  usdFoil: Float
}

input ScryfallPriceListRelationFilter {
  every: ScryfallPriceWhereInput
  none: ScryfallPriceWhereInput
  some: ScryfallPriceWhereInput
}

type ScryfallPriceMaxAggregate {
  cardId: String
  currentPriceOfCardId: String
  date: DateTime
  eur: Float
  eurFoil: Float
  id: String
  tix: Float
  usd: Float
  usdEtched: Float
  usdFoil: Float
}

input ScryfallPriceMaxAggregateInput {
  cardId: Boolean
  currentPriceOfCardId: Boolean
  date: Boolean
  eur: Boolean
  eurFoil: Boolean
  id: Boolean
  tix: Boolean
  usd: Boolean
  usdEtched: Boolean
  usdFoil: Boolean
}

input ScryfallPriceMaxOrderByAggregateInput {
  cardId: SortOrder
  currentPriceOfCardId: SortOrder
  date: SortOrder
  eur: SortOrder
  eurFoil: SortOrder
  id: SortOrder
  tix: SortOrder
  usd: SortOrder
  usdEtched: SortOrder
  usdFoil: SortOrder
}

type ScryfallPriceMinAggregate {
  cardId: String
  currentPriceOfCardId: String
  date: DateTime
  eur: Float
  eurFoil: Float
  id: String
  tix: Float
  usd: Float
  usdEtched: Float
  usdFoil: Float
}

input ScryfallPriceMinAggregateInput {
  cardId: Boolean
  currentPriceOfCardId: Boolean
  date: Boolean
  eur: Boolean
  eurFoil: Boolean
  id: Boolean
  tix: Boolean
  usd: Boolean
  usdEtched: Boolean
  usdFoil: Boolean
}

input ScryfallPriceMinOrderByAggregateInput {
  cardId: SortOrder
  currentPriceOfCardId: SortOrder
  date: SortOrder
  eur: SortOrder
  eurFoil: SortOrder
  id: SortOrder
  tix: SortOrder
  usd: SortOrder
  usdEtched: SortOrder
  usdFoil: SortOrder
}

input ScryfallPriceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ScryfallPriceOrderByWithAggregationInput {
  _avg: ScryfallPriceAvgOrderByAggregateInput
  _count: ScryfallPriceCountOrderByAggregateInput
  _max: ScryfallPriceMaxOrderByAggregateInput
  _min: ScryfallPriceMinOrderByAggregateInput
  _sum: ScryfallPriceSumOrderByAggregateInput
  cardId: SortOrder
  currentPriceOfCardId: SortOrder
  date: SortOrder
  eur: SortOrder
  eurFoil: SortOrder
  id: SortOrder
  tix: SortOrder
  usd: SortOrder
  usdEtched: SortOrder
  usdFoil: SortOrder
}

input ScryfallPriceOrderByWithRelationInput {
  card: ScryfallCardOrderByWithRelationInput
  cardId: SortOrder
  currentPriceOfCard: CardOrderByWithRelationInput
  currentPriceOfCardId: SortOrder
  date: SortOrder
  eur: SortOrder
  eurFoil: SortOrder
  id: SortOrder
  tix: SortOrder
  usd: SortOrder
  usdEtched: SortOrder
  usdFoil: SortOrder
}

input ScryfallPriceRelationFilter {
  is: ScryfallPriceWhereInput
  isNot: ScryfallPriceWhereInput
}

enum ScryfallPriceScalarFieldEnum {
  cardId
  currentPriceOfCardId
  date
  eur
  eurFoil
  id
  tix
  usd
  usdEtched
  usdFoil
}

input ScryfallPriceScalarWhereWithAggregatesInput {
  AND: [ScryfallPriceScalarWhereWithAggregatesInput!]
  NOT: [ScryfallPriceScalarWhereWithAggregatesInput!]
  OR: [ScryfallPriceScalarWhereWithAggregatesInput!]
  cardId: StringWithAggregatesFilter
  currentPriceOfCardId: StringNullableWithAggregatesFilter
  date: DateTimeWithAggregatesFilter
  eur: FloatNullableWithAggregatesFilter
  eurFoil: FloatNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  tix: FloatNullableWithAggregatesFilter
  usd: FloatNullableWithAggregatesFilter
  usdEtched: FloatNullableWithAggregatesFilter
  usdFoil: FloatNullableWithAggregatesFilter
}

type ScryfallPriceSumAggregate {
  eur: Float
  eurFoil: Float
  tix: Float
  usd: Float
  usdEtched: Float
  usdFoil: Float
}

input ScryfallPriceSumAggregateInput {
  eur: Boolean
  eurFoil: Boolean
  tix: Boolean
  usd: Boolean
  usdEtched: Boolean
  usdFoil: Boolean
}

input ScryfallPriceSumOrderByAggregateInput {
  eur: SortOrder
  eurFoil: SortOrder
  tix: SortOrder
  usd: SortOrder
  usdEtched: SortOrder
  usdFoil: SortOrder
}

input ScryfallPriceWhereInput {
  AND: [ScryfallPriceWhereInput!]
  NOT: [ScryfallPriceWhereInput!]
  OR: [ScryfallPriceWhereInput!]
  card: ScryfallCardRelationFilter
  cardId: StringFilter
  currentPriceOfCard: CardRelationFilter
  currentPriceOfCardId: StringNullableFilter
  date: DateTimeFilter
  eur: FloatNullableFilter
  eurFoil: FloatNullableFilter
  id: StringFilter
  tix: FloatNullableFilter
  usd: FloatNullableFilter
  usdEtched: FloatNullableFilter
  usdFoil: FloatNullableFilter
}

input ScryfallPriceWhereUniqueInput {
  currentPriceOfCardId: String
  id: String
}

type ScryfallRelatedCard {
  card: [ScryfallCard!]!
  cardId: String!
  component: String!
  id: ID!
  name: String!
  reference: [ScryfallCard!]!
  referenceId: String!
  typeLine: String!
  uri: String!
}

input ScryfallRelatedCardListRelationFilter {
  every: ScryfallRelatedCardWhereInput
  none: ScryfallRelatedCardWhereInput
  some: ScryfallRelatedCardWhereInput
}

input ScryfallRelatedCardOrderByRelationAggregateInput {
  _count: SortOrder
}

input ScryfallRelatedCardWhereInput {
  AND: [ScryfallRelatedCardWhereInput!]
  NOT: [ScryfallRelatedCardWhereInput!]
  OR: [ScryfallRelatedCardWhereInput!]
  card: ScryfallCardRelationFilter
  cardId: StringFilter
  component: StringFilter
  id: StringFilter
  name: StringFilter
  reference: ScryfallCardRelationFilter
  referenceId: StringFilter
  typeLine: StringFilter
  uri: StringFilter
}

type ScryfallSet {
  _count: ScryfallSetCount!
  arenaCode: String
  block: String
  blockCode: String
  cardCount: Int!
  cards(cursor: ScryfallCardWhereUniqueInput, distinct: [ScryfallCardScalarFieldEnum!], orderBy: [ScryfallCardOrderByWithRelationInput!], skip: Int, take: Int, where: ScryfallCardWhereInput): [ScryfallCard!]!
  code: String!
  iconSvgUri: String!
  id: ID!
  isDigital: Boolean!
  isFoilOnly: Boolean!
  isNonFoilOnly: Boolean!
  mtgoCode: String
  name: String!
  parentSetCode: String
  printedSize: Int
  releasedAt: DateTime
  scryfallUri: String!
  searchUri: String!
  setType: String!
  tcgPlayerId: Int
  uri: String!
}

type ScryfallSetCount {
  cards: Int!
}

input ScryfallSetOrderByWithRelationInput {
  arenaCode: SortOrder
  block: SortOrder
  blockCode: SortOrder
  cardCount: SortOrder
  cards: ScryfallCardOrderByRelationAggregateInput
  code: SortOrder
  iconSvgUri: SortOrder
  id: SortOrder
  isDigital: SortOrder
  isFoilOnly: SortOrder
  isNonFoilOnly: SortOrder
  mtgoCode: SortOrder
  name: SortOrder
  parentSetCode: SortOrder
  printedSize: SortOrder
  releasedAt: SortOrder
  scryfallUri: SortOrder
  searchUri: SortOrder
  setType: SortOrder
  tcgPlayerId: SortOrder
  uri: SortOrder
}

input ScryfallSetRelationFilter {
  is: ScryfallSetWhereInput
  isNot: ScryfallSetWhereInput
}

enum ScryfallSetScalarFieldEnum {
  arenaCode
  block
  blockCode
  cardCount
  code
  iconSvgUri
  id
  isDigital
  isFoilOnly
  isNonFoilOnly
  mtgoCode
  name
  parentSetCode
  printedSize
  releasedAt
  scryfallUri
  searchUri
  setType
  tcgPlayerId
  uri
}

input ScryfallSetWhereInput {
  AND: [ScryfallSetWhereInput!]
  NOT: [ScryfallSetWhereInput!]
  OR: [ScryfallSetWhereInput!]
  arenaCode: StringNullableFilter
  block: StringNullableFilter
  blockCode: StringNullableFilter
  cardCount: IntFilter
  cards: ScryfallCardListRelationFilter
  code: StringFilter
  iconSvgUri: StringFilter
  id: StringFilter
  isDigital: BoolFilter
  isFoilOnly: BoolFilter
  isNonFoilOnly: BoolFilter
  mtgoCode: StringNullableFilter
  name: StringFilter
  parentSetCode: StringNullableFilter
  printedSize: IntNullableFilter
  releasedAt: DateTimeNullableFilter
  scryfallUri: StringFilter
  searchUri: StringFilter
  setType: StringFilter
  tcgPlayerId: IntNullableFilter
  uri: StringFilter
}

input ScryfallSetWhereUniqueInput {
  arenaCode: String
  code: String
  id: String
  mtgoCode: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  _count: UserCount!
  collections: [Collection!]
  email: String!
  externalAuthId: String!
  id: ID!
}

type UserCount {
  collections: Int!
}

input UserOrderByWithRelationInput {
  collections: CollectionOrderByRelationAggregateInput
  email: SortOrder
  externalAuthId: SortOrder
  id: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  collections: CollectionListRelationFilter
  email: StringFilter
  externalAuthId: StringFilter
  id: StringFilter
}